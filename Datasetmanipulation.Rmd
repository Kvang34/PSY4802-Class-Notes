---
title: "Dataset Manipulation"
author: "Amanda Mae Woodward"
date: "2024-10-01"
output: html_document
---

#Learning Outcomes: 
By the end of this class, students should be able to:
- Transform wide data to long
- Transform data from long to wide
- Join data sets in R
- Use functions to clean data
- Use pipes to clean data

We've **already**started manipulating datasets in R. We've talked about how to add columns, how to fill those columns with indexing or for loops, and how to subset data. Today, we'll go through a few other ways to manipulate datasets. But first, we need to go through adding data to R. After all, you aren't going to be using built in data to write your papers.

Uploading data is one of the few things I use a "point and click" method for. Partially, because the point and click method allows you to check if your data are uploading the way you want them to. Today, we'll be using a .csv file, but you can upload other sorts of files. 

You'll want to press the "import dataset" button above your global environment. In this case, you can use the "from text  (base)" option. This should open a window with your files. Select the appropriate file and it should load a preview. It has options where you can make sure your columns have names, missing values are accounted for, and a few other options. 

Once you press okay, you'll see your dataset pop up in the console below. You should move it to your .Rmd file and name it however you'd like. I have a tendency to use "dat", though it's not the most informative. Feel free to use your own name, but remember that whatever you call it here is how you'll refer to it for the rest of the lesson. 

```{r}
#import the dataset from text base 
#copy and paste the file, which is found in the console 

#aggressionData <- read.csv("C:/Users/vang3434/Downloads/PSY4802-AggressionSampleData.csv")

#reccomend using readr to make the data accessible to everyone
library(readr)
aggressionDat<- 
  read_csv("PSY4802-AggressionSampleData.csv")

```
getting/setting wd
```{r}
#to get the data
getwd()

#to save the data into a desktop/folder so you don't have to move it 
setwd(dir = "C:/Users/vang3434/Downloads")
```


### Learning Outcome #1: Transform wide data to long
There are many **many** ways to transform data from wide to long and vice versa. Sometimes, the version you pick is based on what other data you have. 

We also need to determine what type of data we have. To make sure we're all on the same page, a quick review: 
**Long data:** have multiple rows per participants. Each row represents a unique measurement. (in our example, each participant would have two rows: the baseline measure and the measure after the game). 
**Wide data:** There is only one row per participant. Each column represents a unique measurement. (in our example, the data is currently in wide format).

Knowing the type of data you are using and how to change it is important because you may need to change it depending on the analyses you'd like to run and how you'd like to graph the data.  

#### Wide to Long
As mentioned above, the current data are in wide format. We can change this to long format a couple of ways. We're only going to go through the three that I see most often. As a warning, I'm starting with the easiest, and working my way down to the least intuitive. 

**pivot_longer**
I think this is the easiest version to use. We'll need to use the "tidyverse" library. 
```{r}
#install tidyverse library
library(tidyverse)

```
`pivot_longer()` uses the following structure: 
`pivot_longer(dataframe, columns containing wide data, names_to, values_to)`
names_to: specifies what you'd like to call the column that contains the previous column names
values_to: specifies the name of the column where the scores go
```{r}
#long data 
aggressionLong <- pivot_longer(aggressionDat, c("baselineAggression", "postAggression"), names_to="timePoint", values_to="aggressionScore")

#In here, we change the name of the column to "timepoint" and the values to "aggressionScore"
#When we run the code, we know it is a long data when the two line for one particpants is next to each other 
# newDataName <- pivot_longer(dataName, c(), names_to= "newColumnName", values_to= "valueNames)"

#another way of doing this is..
aggressionLongA <- aggressionDat %>% 
  pivot_longer(c("baselineAggression","postAggression"), names_to="timePoint", values_to="aggressionScore")

# newDataName <- dataName %>%
  #pivot(!columnToIgnore, names_to="newColumnName", values_to="valueNames)


# newDataName <- dataName %>% 
  #pivot_longer(dataName, c(colnames(dataName)[first column:last column]), names_to="new column name", values_to="valueNames")
```
**Note:** remember to save the data to your environment. 

#### Learning Outcome 1 Practice
1. Open the relig_income dataset.
```{r}
data("relig_income")

#to learn more about the data, we could write "?relig_income" in the console
```

2. Restructure the dataset so that it is in long format. 
```{r}
colnames(relig_income)

religionIncomeLong <- pivot_longer(relig_income, c("<$10k", "$10-20k","$20-30k","$30-40k","$40-50k", "$50-75k", "$75-100k","$100-150k", ">150k"), names_to= "levels of income", values_to = "income freqency")

```

**gather** 
`gather()` is another function in tidyr that can be used to.
gather has the following arguments `gather(dataframe, key, value, columns to act on)`
key- what you'd like the column containing old column names to be called
value- what you'd like the scores column to be called

```{r}
#this is another way to go from wide to long data format 

#first, install the tidyr library 
library(tidyr)

aggressionLong2 <- gather(aggressionDat, key="timepoint", value="aggressionScore", c("baselineAggression","postAggression"))
#key is the new column name 
#value are the name of values in the column 

```

**melt**
`melt()` is a function in the reshape2 library. It's another way to create long data
```{r}
#install the reshape2 library 
library(reshape2)

```
`melt()` uses the following arguments: 
`melt(dataframe, id.vars, measure.vars, variable.name, value.name)`
```{r}
aggressionLong3 <- melt(aggressionDat, id.vars= c("subjNo","ageGroup","parentReportGender", "condition"), measure.var= 
c("baselineAggression","postAggression"),
variable.name="timepoint", value.name="aggressionScore")

#id.var= are the columns we don't change 
#measure.var= are the columns we will change
```

### Learning Outcome 2: Transform data from long to wide
As above, we'll restructure the data in three ways. Again, some ways are more intuitive than others, and you just need to know how to use one (but it's good to be familiar with multiples). 

**pivot_wider**
The pair function for pivot_longer. It has the following arguments: 
`pivot_wider(dataset, id columns, names_from, values_from)`
```{r}
#Open the billboard data 
data(billboard)

#Looking at the data, it is a wide format 
#Before we transform the data, we should decided what column should be changed in the data.In this data, we would change the week column and add a ranking column 

#transforming a long to wide data 


aggressionWide <- pivot_wider(aggressionLong, id_cols= c(colnames(aggressionLong)[1:4]), names_from="timePoint", values_from="aggressionScore")

```

**spread** 
is the pair function for gather. It has the following arguments: 
`spread(data, key, value, columns to make wide)`
key = timepoint; value = aggression score
```{r}
aggressionWide2 <- spread(aggressionLong, key= "timePoint", value=aggressionScore)
```

**dcast**
cast functions are the pairs to melt. `dcast()` specifically is used for dataframes. 
dcast has the following arguments: 
`dcast(data, formula)`
```{r}
#datWide3<- dcast(aggressionLong3, formula= subjNo+ ageGroup+parentReportGender+condition~variable)

#format: newDataName <- dcast(dataName, formula= list the column that change ~ column that don't change)

aggressionWide3 <- dcast(aggressionLong, formula= subjNo + ageGroup + parentReportGender + condition ~ timePoint)
```
**Note:** dcast is really not intuitive. I pretty much determine the correct order through trial and error every time. 

#### Learning Outcome 2: Practice
1. Open the ChickWeight dataset.
```{r}
data(ChickWeight)
```

2. Convert it from long to wide format. 
```{r}
colnames(ChickWeight)
chickWide <- pivot_wider(ChickWeight, id_cols = c("Chick","Diet"), names_from = "Time", values_from="weight")
```

3. Convert from wide to long. 
```{r}
chickLong <- pivot_longer(chickWide, cols= c(colnames(chickWide)[3:14]), names_to = "Time", values_to = "Weight")
```


### A note on pipes for data restructuring
A lot of the functions we've covered above can also be used with pipes. Here, we'll go through some ways that you can use pipes to restructure your data. 

First, remember that pipes are used in the following way 

`dataframe %>% function(function arguments)`

you can use some of the commands we've already used in a different structure
**pivot_longer w/pipes**
`data %>% pivot_longer(columns used, name for "name" column, name for "value column")`

```{r}
chickLong1 <- chickWide %>% 
  pivot_longer(cols= c(colnames(chickWide)[3:14]), names_to= "time", values_to= "weight") %>%
  filter(Chick==1)

```

###Practice: 

1) open sleep data set
```{r}
data(sleep)
```

2) identify the type of data
```{r}
#It is a long data
```

3) change it to the other type

```{r}
#Change from long to wide data 

sleepWide <- sleep %>%
  pivot_wider(names_from= "group", values_from= "extra")

#name is the new column
#values are argument we want to put inside the cell


```
4) Go back to the chick weight dataset and take all data from chick 3 and put it in wide format 
```{r}
data("ChickWeight")
```

```{r}
#Column names
colnames(ChickWeight)

#Data with three chicks
chickThree <- ChickWeight %>%
  filter(Chick == 3)

#It is a long data, so we gotta convert to a wide data 
chickThreeWide <- chickThree %>%
  pivot_wider(names_from = "Time", values_from="weight")

```

### Learning Outcome 3: Join data sets in R
Some times, we have datasets that we need to join or merge (e.g. participant demographics in one file and responses in a second). We can combine these datasets using "join." If you've ever used/heard of SQL, join works the same way in R

We'll practice on the following code: 
Make a data frame with subject number and simulated anxiety scores
```{r}
subjNo <- aggressionDat$subjNo
anxietyScore <- sample(x= 1:20, size = nrow(aggressionDat), replace= TRUE)

#x is what you're sampling from 
# size is the number of things to pull
# replace is true 

AnxietyData <- cbind.data.frame(subjNo, anxietyScore)

# When we run the data, we have another graph that shows the subjNo and anxietyScore 

```
use `left_join()`
```{r}

# to combine the data together, we will use 'left_join(data we want in the front, data we want in the back/next)'

library(dplyr)
datFinal <- left_join(aggressionDat, AnxietyData)
```

`right_join()` does the same thing, but places the new column to the right. 

#### Learning Outcome 3 Practice
1. Create a dataframe (n=48) that includes subject numbers and executive function scores (ranging from 0-16).
```{r}

subjNo <- aggressionDat$subjNo 
EF <- sample(x= 0:16, size = nrow(aggressionDat), replace= TRUE)
EFdata <- cbind.data.frame(subjNo, EF)
```

2. Join your dataset in #1 to the original Aggression dataset. 
```{r}
dat <- left_join(datFinal, EFdata)
```

### Learning Outcomes 4 & 5: Use functions to clean data (and pipes)
Now that we've covered how to restructure data, we'll talk about ways to clean it. These are just some of the functions I find myself using, and there are certainly more. This section is a bit longer, so there will be practice questions mixed in. 

**Changing levels** 
As we talked about before, there are different classes(or types) of data in R. For factors, you can change the specific levels (or categories) within the factor. 

*using levels()*
Let's take the example from our final dataset (datFinal). We can change parentReportGender to have levels of "boy" and "girl."
we'll check what class it is first
```{r}
finaldata$parentReportGender

# When we run the code, we have "M" and "F"
```
it's currently a character, so we can change it to a factor using as.factor (which we talked about last week). Then, we can use the function `levels()` to change the data. 

Note: because I saved these as different columns, I can directly compare the data held in each to ensure I've changed everything correctly. 

Also, keep in mind that changing levels of a factor requires you to know **know what levels are currently in your data.** You can check this by either printing the column as I've done above, or using the levels command:
`factor(data, levels = x,y,z)`
```{r}
aggressionDat$parentReportGender <- as.factor(aggressionDat$parentReportGender)

levels(aggressionDat$parentReportGender) <- c("girl","boy")

# level (dataName$columnName) <- c(first value, second value)

# Another way to do this is by

aggressionDat$parentReportGender <- factor(aggressionDat$parentReportGender, levels= c("girl", "boy"))

# To check the order is correct by writing 'dataName$columnName' 
aggressionDat$parentReportGender

# When we run the code, 'M' appear as 'boy' and 'F' as 'girl'
```
I'd recommend this version, particularly if you have a large data set. 

#### Practice: 
1. Create a column in the final dataset that contains condition as a factor. 
```{r}
datfinal$factors <- datfinal$condition

```

2. Change the levels to "e" for exclusion and "i" for inclusion. 
```{r}

datfinal$factors <- as.factor(datfinal$factors)

levels(dafinal$factors) <- c("e","i")

```

3. Check that you have done this successfully. 
```{r}
datfinal$factors


```

**reordering factors**
You may have noticed that writes levels of a factor in alphabetical order. Sometimes, this is really helpful. Other times, it can complicate statistical models and graphs because there are more meaningful ways to reorder your data. You can reorder the data using relevel. 
It has the general structure `relevel(column, reference level)`
```{r}
aggressionDat <- relevel(aggressionDat$parentReportGender, ref= "girl")
```
If you have more levels, you can specify the order in your factor function 

`factor(dataName$columnName, levels= order of levels)`

#### Practice
1. Reorder the condition variable in your final dataset so that inclusion is the reference category. 
```{r}

```

**Reverse Coding**
For those of you who have survey data, you may be interested in using a function to reverse code certain items. You can use `recode()` to do so. 
`recode(column to be coded, what recode looks like)`

I'm going to make a new column to demonstrate this.
```{r}
aggressionDat$attention <- rep(1:6,8)
aggressionDat$attention
```
To reverse code it, we would write
`recode(data, 'how to recode')`
There is also a recode in the car package
```{r}
# install the car library, but my packages doesn't have it ??

library(callr)
# aggressionDat$attention <- carl:: record(aggressionDat$attention, "6=1; 5=2; 4=3; 3=4;2=5;1=6")

```
Note: you'll notice that I wrote "car::" before the record function. This is necessary sometimes. Remember, the libraries are made by **different** people. People use the same words for different functions. So we need to tell R which of the functions we want to use. 

**separate**
we can also use separate to take information in one column and place it in multiple columns
separate uses the following arguments:
`separate(data, columns, into, sep)`
let's look at the subject column in our dataset
```{r}
# aggressionDat %>% separate(subjNo, into = c("condition2", "subj"), sep=1)
```

**Mutate** 
When you are cleaning data, there are occasionally instances where you need to use your current data to create new columns. Mutate can be used for many applications, including conversions (Dev Psych: Days to Months to Years approximation; Temperature from C to F).

To practice using Mutate, we're going to use a messier dataset
```{r}
data("starwars")
```

If you open the dataset, you can see that we have both height and mass variables. You can see that height is in cm, so we can convert height to inches
```{r}
starwars2 <- starwars %>% mutate(meters=height*100)
```







 


